// https://zhuanlan.zhihu.com/p/267884783 算法学习笔记(55): Pollard-Rho算法
// 时间复杂度：O(N^(1/4))
// 额外空间复杂度：O(1)
package main

import (
	"fmt"
	"math/big"
	"math/rand"
	"time"
)

func PollardRho(N *big.Int) *big.Int {
	if N.Cmp(big.NewInt(4)) == 0 {
		return big.NewInt(2)
	}
	if N.ProbablyPrime(0) {
		return N
	}

	rr := rand.New(rand.NewSource(time.Now().Unix()))
	for {
		c := new(big.Int).Rand(rr, new(big.Int).Sub(N, big.NewInt(1)))
		f := func(x *big.Int) *big.Int { return new(big.Int).Mod(new(big.Int).Add(new(big.Int).Mul(x, x), c), N) }

		t := big.NewInt(0)
		r := big.NewInt(0)
		p := big.NewInt(1)

		for i := 0; i < 128; i++ {
			t.Set(f(t))
			r.Set(f(f(r)))
			if t.Cmp(r) == 0 {
				break
			}
			q := new(big.Int).Abs(new(big.Int).Sub(t, r))
			q.Mul(q, p)
			q.Mod(q, N)
			if q.Cmp(big.NewInt(0)) == 0 {
				break
			}
			p.Set(q)
		}

		d := new(big.Int).GCD(nil, nil, p, N)
		if d.Cmp(big.NewInt(1)) > 0 && d.Cmp(N) < 0 {
			return d
		}
	}
}

func main() {
	N := big.NewInt(98765432101234567)
	result := PollardRho(N)
	fmt.Println(result.String())
}
